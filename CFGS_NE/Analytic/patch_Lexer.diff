--- a/Lexer.cs
+++ b/Lexer.cs
@@ -94,93 +94,162 @@
             if (c == '"')
             {
                 SyncPos();
-                string s = "";
-                while (Current != '"' && Current != '\0') { s += Current; SyncPos(); }
+                var sb = new StringBuilder();
+                while (Current != '"' && Current != '\0')
+                {
+                    if (Current == '\\')
+                    {
+                        SyncPos();
+                        char esc = Current;
+                        if (esc == 'n') { sb.Append('\n'); }
+                        else if (esc == 't') { sb.Append('\t'); }
+                        else if (esc == 'r') { sb.Append('\r'); }
+                        else if (esc == '"') { sb.Append('"'); }
+                        else if (esc == '\\') { sb.Append('\\'); }
+                        else if (esc == 'u') {
+                            // Unicode escape \uXXXX
+                            SyncPos();
+                            int h1 = Current; SyncPos();
+                            int h2 = Current; SyncPos();
+                            int h3 = Current; SyncPos();
+                            int h4 = Current;
+                            string hex = new string(new[]{(char)h1,(char)h2,(char)h3,(char)h4});
+                            if (!int.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int code))
+                                throw new LexerException($"invalid unicode escape \\u{hex}", _line, _col, FileName);
+                            sb.Append((char)code);
+                        }
+                        else { sb.Append(esc); }
+                        SyncPos();
+                    }
+                    else
+                    {
+                        sb.Append(Current);
+                        SyncPos();
+                    }
+                }
                 if (Current != '"') throw new LexerException("unterminated string literal", _line, _col, FileName);
                 SyncPos();
-                return MakeToken(TokenType.String, s);
+                return MakeToken(TokenType.String, sb.ToString());
+            }
             }
 
             if (c == '\'')
             {
                 SyncPos();
-                string s = "";
-                while (Current != '\'' && Current != '\0') { s += Current; SyncPos(); }
+                char value;
+                if (Current == '\\')
+                {
+                    SyncPos();
+                    char esc = Current;
+                    value = esc switch
+                    {
+                        'n' => '\n',
+                        't' => '\t',
+                        'r' => '\r',
+                        '\'' => '\'',
+                        '"' => '"',
+                        '\\' => '\\',
+                        _ => esc,
+                    };
+                    SyncPos();
+                }
+                else
+                {
+                    value = Current;
+                    if (value == '\0' || value == '\n')
+                        throw new LexerException("unterminated char literal", _line, _col, FileName);
+                    SyncPos();
+                }
                 if (Current != '\'') throw new LexerException("unterminated char literal", _line, _col, FileName);
                 SyncPos();
-                return MakeToken(TokenType.Char, s);
+                return MakeToken(TokenType.Char, value.ToString());
+            }
             }
 
             if (char.IsDigit(Current))
             {
                 int startLine = _line, startCol = _col;
                 var sb = new StringBuilder();
-                bool hasDot = false;
-                bool hasExp = false;
-
-                while (char.IsDigit(Current))
-                {
-                    sb.Append(Current);
-                    SyncPos();
-                }
-
+                bool isHex = false, isBin = false, isOct = false;
+                bool hasDot = false, hasExp = false;
+
+                // Leading 0 with base prefix
+                if (Current == '0' && (Peek == 'x' || Peek == 'X' || Peek == 'b' || Peek == 'B' || Peek == 'o' || Peek == 'O'))
+                {
+                    char p = Peek;
+                    SyncPos(2); // consume 0 and prefix
+                    while (Current != '\0' && (char.IsLetterOrDigit(Current) || Current == '_'))
+                    {
+                        if (Current != '_') sb.Append(Current);
+                        SyncPos();
+                    }
+                    string digits = sb.ToString();
+                    object value;
+                    if (p == 'x' || p == 'X') {
+                        if (!ulong.TryParse(digits, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var v))
+                            throw new LexerException($"invalid hex literal '0{p}{digits}'", startLine, startCol, FileName);
+                        value = v <= int.MaxValue ? (object)(int)v : (long)v;
+                    }
+                    else if (p == 'b' || p == 'B') {
+                        if (!System.Text.RegularExpressions.Regex.IsMatch(digits, "^[01]+$"))
+                            throw new LexerException($"invalid binary literal '0{p}{digits}'", startLine, startCol, FileName);
+                        ulong v = 0;
+                        foreach (char ch in digits) v = (v << 1) + (ulong)(ch - '0');
+                        value = v <= int.MaxValue ? (object)(int)v : (long)v;
+                    }
+                    else { // 'o' or 'O'
+                        if (!System.Text.RegularExpressions.Regex.IsMatch(digits, "^[0-7]+$"))
+                            throw new LexerException($"invalid octal literal '0{p}{digits}'", startLine, startCol, FileName);
+                        ulong v = 0;
+                        foreach (char ch in digits) v = (v << 3) + (ulong)(ch - '0');
+                        value = v <= int.MaxValue ? (object)(int)v : (long)v;
+                    }
+                    return new Token(TokenType.Number, value, startLine, startCol, FileName);
+                }
+
+                // Decimal/float with optional underscores
+                while (char.IsDigit(Current) || Current == '_')
+                {
+                    if (Current != '_') sb.Append(Current);
+                    SyncPos();
+                }
                 if (Current == '.' && char.IsDigit(Peek))
                 {
                     hasDot = true;
                     sb.Append(Current);
                     SyncPos();
-                    while (char.IsDigit(Current))
-                    {
-                        sb.Append(Current);
-                        SyncPos();
-                    }
-                }
-
+                    while (char.IsDigit(Current) || Current == '_')
+                    {
+                        if (Current != '_') sb.Append(Current);
+                        SyncPos();
+                    }
+                }
                 if (Current == 'e' || Current == 'E')
                 {
                     hasExp = true;
                     sb.Append(Current);
                     SyncPos();
-
-                    if (Current == '+' || Current == '-')
-                    {
-                        sb.Append(Current);
-                        SyncPos();
-                    }
-
-                    if (!char.IsDigit(Current))
-                        throw new LexerException("invalid float exponent (missing digits)", _line, _col, FileName);
-
-                    while (char.IsDigit(Current))
-                    {
-                        sb.Append(Current);
-                        SyncPos();
-                    }
-                }
-
-                var num = sb.ToString();
-                object value;
-
+                    if (Current == '+' || Current == '-') { sb.Append(Current); SyncPos(); }
+                    if (!char.IsDigit(Current)) throw new LexerException("invalid float exponent", startLine, startCol, FileName);
+                    while (char.IsDigit(Current) || Current == '_') { if (Current != '_') sb.Append(Current); SyncPos(); }
+                }
+                string num = sb.ToString();
+                object val;
                 if (hasDot || hasExp)
                 {
-                    if (double.TryParse(num, NumberStyles.Float, CultureInfo.InvariantCulture, out var d))
-                        value = d;
-                    else
+                    if (!double.TryParse(num, NumberStyles.Float, CultureInfo.InvariantCulture, out var d))
                         throw new LexerException($"invalid float literal '{num}'", startLine, startCol, FileName);
+                    val = d;
                 }
                 else
                 {
-                    if (int.TryParse(num, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i))
-                        value = i;
-                    else if (long.TryParse(num, NumberStyles.Integer, CultureInfo.InvariantCulture, out var l))
-                        value = l;
-                    else if (decimal.TryParse(num, NumberStyles.Number, CultureInfo.InvariantCulture, out var m))
-                        value = m;
-                    else
-                        throw new LexerException($"invalid number literal '{num}'", startLine, startCol, FileName);
-                }
-
-                return new Token(TokenType.Number, value, startLine, startCol, FileName);
+                    if (int.TryParse(num, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i)) val = i;
+                    else if (long.TryParse(num, NumberStyles.Integer, CultureInfo.InvariantCulture, out var l)) val = l;
+                    else if (decimal.TryParse(num, NumberStyles.Number, CultureInfo.InvariantCulture, out var m)) val = m;
+                    else throw new LexerException($"invalid number literal '{num}'", startLine, startCol, FileName);
+                }
+                return new Token(TokenType.Number, val, startLine, startCol, FileName);
+            }
             }
 
             if (char.IsLetter(c) || c == '_')