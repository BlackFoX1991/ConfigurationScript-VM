# CFGS Try/Catch/Finally – Edge Case Suite PLUS (funktional verpackt)
# Jede try hat mindestens catch UND finally.

print("=== TRY/CATCH/FINALLY EDGE TESTS PLUS START ===");

func sep(name) { print("-- " + name + " --"); }

# 1) Throw im inneren finally überschreibt frühere Exception
func test1() {
    try {
        try {
            print("1.inner.try (kein Throw)");
        } catch (e) {
            print("1.inner.catch (sollte NICHT)");
        } finally {
            print("1.inner.finally (wirft jetzt NEU)");
            throw "1-FINALLY";
        }
        print("1.outer.try (nach inner) (sollte NICHT)");
    } catch (e) {
        print("1.outer.catch e=" + str(e));  # erwartet: 1-FINALLY
    } finally {
        print("1.outer.finally");
    }
}

# 2a) return in finally überschreibt return aus try
func f2a() {
    try {
        print("2a.try (return 'TRY')");
        return "TRY";
    } catch (e) {
        print("2a.catch (sollte NICHT)");
        return "CATCH";
    } finally {
        print("2a.finally (return 'FINALLY')");
        return "FINALLY";
    }
}
func test2a() {
    print("2a.result=" + str(f2a()));
}

# 2b) return in finally überschreibt return aus catch
func f2b() {
    try {
        print("2b.try (wirft)");
        throw "X";
    } catch (e) {
        print("2b.catch (return 'CATCH')");
        return "CATCH";
    } finally {
        print("2b.finally (return 'FINALLY')");
        return "FINALLY";
    }
}
func test2b() {
    print("2b.result=" + str(f2b()));
}

# 3a) continue aus catch -> finally läuft davor
func test3a() {
    for (var i = 0; i < 3; i += 1;) {
        print("3a.loop i=" + str(i) + " (enter)");
        try {
            if (i == 1) {
                print("3a.try (wirft für continue)");
                throw "CONT";
            }
            print("3a.try (kein Fehler i=" + str(i) + ")");
        } catch (e) {
            print("3a.catch i=" + str(i) + " e=" + str(e) + " (continue)");
            continue;
        } finally {
            print("3a.finally (läuft vor continue/weiter)");
        }
        print("3a.loop i=" + str(i) + " (after try)");
    }
    print("3a.after loop");
}

# 3b) break aus catch -> finally läuft davor
func test3b() {
    for (var j = 0; j < 4; j += 1;) {
        print("3b.loop j=" + str(j) + " (enter)");
        try {
            if (j == 2) {
                print("3b.try (wirft für break)");
                throw "BRK";
            }
            print("3b.try (kein Fehler j=" + str(j) + ")");
        } catch (e) {
            print("3b.catch j=" + str(j) + " e=" + str(e) + " (break)");
            break;
        } finally {
            print("3b.finally (läuft vor break/weiter)");
        }
        print("3b.loop j=" + str(j) + " (after try)");
    }
    print("3b.after loop");
}

# 4) Tiefe Kaskade (return + throw + finally)
func inner_return() {
    try {
        print("4.inner_return.try (return) ");
        return "IR";
    } catch (e) {
        print("4.inner_return.catch (NICHT)");
        return "IRC";
    } finally {
        print("4.inner_return.finally");
    }
}
func inner_throw() {
    try {
        print("4.inner_throw.try (throw)");
        throw "IT";
    } catch (e) {
        print("4.inner_throw.catch (rethrow)");
        throw e;
    } finally {
        print("4.inner_throw.finally");
    }
}
func test4() {
    try {
        var a = inner_return();                       # finally von inner_return
        print("4.outer.try nach inner_return a=" + str(a));
        inner_throw();                                # wirft; wird unten gefangen
        print("4.outer.try (nach inner_throw) (NICHT)");
    } catch (e) {
        print("4.outer.catch e=" + str(e));
    } finally {
        print("4.outer.finally");
    }
}

# 5) Neue Exception im catch vs. rethrow
func throw_and_new() {
    try {
        print("5.func.try (throw ORIG)");
        throw "ORIG";
    } catch (e) {
        print("5.func.catch (throw NEW)");
        throw "NEW";
    } finally {
        print("5.func.finally");
    }
}
func throw_and_rethrow() {
    try {
        print("5.func2.try (throw ORIG2)");
        throw "ORIG2";
    } catch (e) {
        print("5.func2.catch (rethrow)");
        throw e;
    } finally {
        print("5.func2.finally");
    }
}
func test5() {
    try {
        try {
            throw_and_new();
        } catch (e) {
            print("5.outer.catch1 e=" + str(e));   # erwartet: NEW
        } finally {
            print("5.outer.finally1");
        }
        try {
            throw_and_rethrow();
        } catch (e) {
            print("5.outer.catch2 e=" + str(e));   # erwartet: ORIG2
        } finally {
            print("5.outer.finally2");
        }
    } catch (e) {
        print("5.outer.OUTER catch (NICHT)");
    } finally {
        print("5.outer.OUTER finally");
    }
}

# --- Aufrufe am Top-Level (nur erlaubte Statements) ---
sep("1: throw im inneren finally überschreibt vorherige");
test1();

sep("2a: return in finally überschreibt return aus try");
test2a();

sep("2b: return in finally überschreibt return aus catch");
test2b();

sep("3a: continue aus catch -> finally vorher");
test3a();

sep("3b: break aus catch -> finally vorher");
test3b();

sep("4: tiefe Kaskade (return + throw + finally)");
test4();

sep("5: neue Exception im catch vs rethrow");
test5();

print("=== TRY/CATCH/FINALLY EDGE TESTS PLUS END ===");
