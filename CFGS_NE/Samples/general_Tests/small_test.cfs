# ===== Mini-Test-Helpers =====
var failed = 0;

func assert_eq(name, actual, expected) {
    if (actual == expected) {
        print("OK   " + name + " = " + str(actual));
    } else {
        print("FAIL " + name + " -> got " + str(actual) + ", expected " + str(expected));
        failed = failed + 1;
    }
}

# ===== Klassen mit statischen Feldern/Methoden/Enums =====
class PointA(x, y)
{
    static var x = 200;

    static func getX() { return type.x; }
    static func setX(v) { type.x = v; }
    static func inc() { type.x = type.x + 1; }     # normaler Inkrement
    static func add(delta) { type.x += delta; }    # Compound-Assign auf static

    func readX() { return type.x; }                # Instanz liest static
    func writeX(v) { type.x = v; }                 # Instanz schreibt static
    func bump() { type.x += 5; }                   # Instanz: Compound-Assign auf static
    func post() { type.x++; return type.x; }       # Instanz: Postfix ++ auf static

    enum Color {
        Red = 1,
        Green = 2,
        Blue = 3
    }
}

# Zweite Klasse, um Unabhängigkeit & eigene statics zu testen
class Counter(start)
{
    static var total = 0;

    static func reset() { type.total = 0; }
    static func totalGet() { return type.total; }
    static func totalAdd(v) { type.total += v; }

    func add(v) { type.total += v; }
    func tick() { type.total++; }
}

func main()
{
    # ===== Grund-Checks: Konstruktion & typeof =====
    var t = new PointA(10, 20);
    assert_eq("typeof_instance", typeof(t), "PointA");
    assert_eq("typeof_class",   typeof(PointA), "PointA");

    # ===== Statische Grundwerte & Methodenaufrufe =====
    assert_eq("PointA.getX_init", PointA.getX(), 200);

    # Klassen-Seite schreibt static:
    PointA.setX(300);
    assert_eq("PointA.getX_after_setX", PointA.getX(), 300);

    # Instanz liest static:
    assert_eq("t.readX_after_class_set", t.readX(), 300);

    # Instanz schreibt static:
    t.writeX(1234);
    assert_eq("PointA.getX_after_instance_write", PointA.getX(), 1234);

    # ===== Compound-Assign & ++ auf static (Klasse & Instanz) =====
    PointA.add(6);
    assert_eq("PointA.add(+6)", PointA.getX(), 1240);

    PointA.inc();
    assert_eq("PointA.inc()", PointA.getX(), 1241);

    t.bump();                  # +5
    assert_eq("t.bump(+5)", PointA.getX(), 1246);

    assert_eq("t.post() returns", t.post(), 1247); # post++: return nach ++ in dieser Semantik
    assert_eq("after t.post()", PointA.getX(), 1247);

    # Mehrere Instanzen teilen denselben static-Container:
    var t2 = new PointA(1, 2);
    assert_eq("t2.readX_shares_static", t2.readX(), 1247);

    # ===== Enum in der Klasse (statisch) =====
    # Direkter Zugriff auf Enum-Werte
    assert_eq("enum_value_red",   PointA.Color["Red"], 1);
    assert_eq("enum_value_green", PointA.Color["Green"], 2);
    assert_eq("enum_value_blue",  PointA.Color["Blue"], 3);

    # Reverse-Mapping über "Name"
    assert_eq("enum_name_1", PointA.Color.name(1), "Red");
    assert_eq("enum_name_3", PointA.Color.name(3), "Blue");

    # ===== Zweite Klasse: unabhängiger static-Container =====
    Counter.reset();
    assert_eq("Counter.total_after_reset", Counter.totalGet(), 0);

    var c1 = new Counter(0);
    var c2 = new Counter(0);

    Counter.totalAdd(5);
    assert_eq("Counter.total_after_class_add5", Counter.totalGet(), 5);

    c1.add(10);
    assert_eq("Counter.total_after_c1_add10", Counter.totalGet(), 15);

    c2.tick(); # ++
    assert_eq("Counter.total_after_c2_tick", Counter.totalGet(), 16);

    # Nochmal getrennt prüfen, dass PointA-Statics unberührt bleiben:
    assert_eq("PointA.static_is_independent", PointA.getX(), 1247);

    # ===== Direkte Nutzung in Methodenketten / Verschachtelung =====
    # t.readX() als Argument in Join-ähnlicher Funktion
    func join3(a, b, c) { return str(a) + ":" + str(b) + ":" + str(c); }
    assert_eq("join3_with_static_reads", join3(t.readX(), t2.readX(), PointA.getX()), "1247:1247:1247");

    # ===== Arrays/Dicts (inkl. Push-Syntax) =====
    var arr = [1, 2, 3];
    arr[] = 99;                       # push
    assert_eq("array_push", arr[3], 99);
    arr[1] = arr[1] + 10;             # 2 -> 12
    assert_eq("array_set_rot", arr[1], 12);

    var d = {"a": 1};
    d[] = {"b": 2};                   # dict-push (fügt Key/Value ein)
    assert_eq("dict_push_add_b", d["b"], 2);
    d["c"] = 3;
    assert_eq("dict_set_c", d["c"], 3);

    # ===== Kombi: statische Werte in Container ablegen =====
    var snap = {};
    snap["px"] = PointA.getX();
    assert_eq("snapshot_px", snap["px"], 1247);

    # ===== Noch ein paar Guard-Checks (keine Lambdas, keine Ternarys, nur Semikolons) =====
    # bools/branches kurz sanity:
    var ok = 0;
    if (true) { ok = ok + 1; }
    if (false) { ok = ok + 10; }
    assert_eq("bool_branching", ok, 1);

    # ===== Finale Ausgabe =====
    if (failed == 0) {
        print("ALL TESTS PASSED");
    } else {
        print("TESTS FAILED: " + str(failed));
    }
}
main();