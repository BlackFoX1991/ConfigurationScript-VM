# ===== Mini-Test-Helpers =====
var failed = 0;

func assert_eq(name, actual, expected) {
    if (actual == expected) {
        print("OK   " + name + " = " + str(actual));
    } else {
        print("FAIL " + name + " -> got " + str(actual) + ", expected " + str(expected));
        failed = failed + 1;
    }
}

# ===== Binäre Operatoren / Reihenfolge / Assoziativität =====
var a = 7;
var b = 3;
assert_eq("bin_add", a + b, 10);
assert_eq("bin_sub", a - b, 4);
assert_eq("bin_mul", a * b, 21);
assert_eq("bin_mod", a % b, 1);

# Vergleichsoperatoren (die es gibt)
assert_eq("cmp_eq_true",  a == 7, true);
assert_eq("cmp_eq_false", a == 8, false);
assert_eq("cmp_lt_true",  b < a,  true);
assert_eq("cmp_le_true",  b <= 3, true);
assert_eq("cmp_le_false", b <= 2, false);

# String-Verkettung: linksassoziativ, Reihenfolge muss exakt bleiben
var s1 = "A";
var s2 = "B";
var s3 = "C";
assert_eq("str_concat_assoc", s1 + ":" + s2 + ":" + s3, "A:B:C");

# Zahlen in String-Kette explizit mit str() (wie in deinem While-Test)
assert_eq("str_concat_num", "X=" + str(12) + ":" + str(34), "X=12:34");

# ===== Funktionen & Call-Argument-Reihenfolge =====
func join2(x, y) { return str(x) + ":" + str(y); }
assert_eq("call_arg_order_fn", join2(1, 2), "1:2");

# ===== Arrays: Index-Get/Set & ROT-Pfad =====
var arr = [10, 20, 30];
arr[1] = arr[1] + 5;       # 20 -> 25
assert_eq("array_set_rot", arr[1], 25);

# ===== Dictionaries: Dot/Bracket Get/Set, Delete -> 0 =====
var cfg = {"mode": "fast", "retries": 2};
assert_eq("dict_dot_get", cfg.mode, "fast");
cfg.mode = "slow";
assert_eq("dict_dot_set", cfg.mode, "slow");
cfg["retries"] = 5;
assert_eq("dict_br_set", cfg["retries"], 5);

# ===== Closures: Capture & Isolation =====
func makeAdder(x) { return func(y) { return x + y; }; }
var add3 = makeAdder(3);
var add9 = makeAdder(9);
assert_eq("closure_add3", add3(4), 7);
assert_eq("closure_add9", add9(1), 10);

# Capture nach Mutation
var cap = 2;
var getCap = func() { return cap; };
assert_eq("closure_cap_before", getCap(), 2);
cap = 11;
assert_eq("closure_cap_after", getCap(), 11);

# ===== Loops & Control-Flow =====
# while: 1..5 als String
var i = 1;
var seen = "";
while (i <= 5) {
    seen = seen + str(i);
    i = i + 1;
}
assert_eq("while_1_to_5", seen, "12345");

# for: Produkt 1..4 = 24
var prod = 1;
for (var j = 1; j <= 4; j++;) { prod = prod * j; }
assert_eq("for_prod_1_4", prod, 24);

# continue/break: Summe ungerader Zahlen < 10
var n = 10;
var oddSum = 0;
while (true) {
    n = n - 1;
    if (n % 2 == 0) { continue; }
    oddSum = oddSum + n;
    if (n <= 1) { break; }
}
assert_eq("while_odd_sum", oddSum, 25);

# ===== Klassen: ctor-Param->Felder, this, Methoden & Reihenfolge =====
class Pair(x, y) {
    func asText() { return str(this.x) + ":" + str(this.y); }
    func swap()   { return str(this.y) + ":" + str(this.x); }
}
var p = new Pair(7, 9);
assert_eq("class_ctor_fields", p.asText(), "7:9"); # ctor-Params müssen als Felder übernommen sein
assert_eq("class_method_this", p.swap(),   "9:7"); # Zugriff über this, Reihenfolge geprüft

# Methoden mit zusätzlichem Param (Receiver + Param)
class Acc(v) {
    func add(delta) { return this.v + delta; }
}
var acc = new Acc(10);
assert_eq("method_with_arg", acc.add(5), 15);

# Verschachtelte Nutzung: Methodenergebnis als Argument
assert_eq("nested_call_chain", join2(p.asText(), acc.add(2)), "7:9:12");


# ===== Edge-Checks (optional) =====
assert_eq("cmp_string_num_eq_false", "7" == 7, false);
assert_eq("cmp_neg_lt", (-5) < 0, true);
assert_eq("cmp_neg_le", (-5) <= -5, true);
assert_eq("mod_negative", (-7) % 5, -2);     # übliches mathematisches Mod-Verhalten

# Division (falls / vorhanden und integer-truncated sein soll, anpassen)
var d = 7 / 3;                # wenn deine VM ganzzahlig teilt -> 2; sonst 2.333...
assert_eq("div_behavior", d, 2);  # ggf. 2.333... erwarten, je nach Implementierung

# Dict: fehlender Key -> 0/null? (hier: 0 wie in deinem Delete-Test)
var tmp = {"a": 1};
assert_eq("dict_missing_key", tmp["zzz"], null);

# Booleans in if/JMP_IF_FALSE (True/False vs. 1/0)
var tcount = 0;
if (true)  { tcount = tcount + 1; }
if (false) { tcount = tcount + 10; }
assert_eq("bool_branching", tcount, 1);



# ===== Finale Ausgabe =====
if (failed == 0) {
    print("ALL TESTS PASSED");
} else {
    print("TESTS FAILED: " + str(failed));
}
