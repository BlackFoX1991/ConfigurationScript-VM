class MdRenderer
{
    # --- internal state ---
    var _state;      # { ul, ol, p, code, tbl, bq }
    var _codebuf;    # fenced code buffer

    # --- paragraph buffer (for Setext support) ---
    var _pbuf;       # accumulates current paragraph lines (already inline-rendered with \n)

    # --- table state ---
    var _tbuf;        # table lines buffered as a single string with '\n'
    var _tbl_prefix;  # html emitted before table (<p>/<ul>/<ol> closures)

    # --- math masking ---
    var _math;        # array of raw math segments, including delimiters
    var _mathi;       # index counter for placeholders

    # --- code-span masking (to keep $ inside `code` literal) ---
    var _spans;       # array of raw code spans, including backticks
    var _spani;       # index counter for placeholders

    # --- public API ---
    func render(md)
    {
        var in_ul = false;
        var in_ol = false;
        var in_p  = false;
        var in_code = false;
        var in_tbl = false;
        var bq_level = 0;   # track current blockquote nesting level

        this._pbuf = "";    # reset paragraph buffer

        var frameOut = "";
        var line = "";
        var i = 0;
        var n = md.len();

        while (i < n)
        {
            var ch = md.substr(i, 1);
            if (ch == "\r") { i = i + 1; continue; }

            if (ch != "\n")
            {
                line = line + ch;
            }
            else
            {
                frameOut = frameOut + this._render_line(line, in_ul, in_ol, in_p, in_code, in_tbl, bq_level);
                in_ul   = this._state["ul"];
                in_ol   = this._state["ol"];
                in_p    = this._state["p"];
                in_code = this._state["code"];
                in_tbl  = this._state["tbl"];
                bq_level= this._state["bq"];
                line = "";
            }
            i = i + 1;
        }

        # flush last line
        if (line.len() > 0)
        {
            frameOut = frameOut + this._render_line(line, in_ul, in_ol, in_p, in_code, in_tbl, bq_level);
            in_ul   = this._state["ul"];
            in_ol   = this._state["ol"];
            in_p    = this._state["p"];
            in_code = this._state["code"];
            in_tbl  = this._state["tbl"];
            bq_level= this._state["bq"];
        }

        # close open blocks
        if (in_code)
        {
            var normTail = this._normalize_code_block(this._codebuf);
            frameOut = frameOut + this._escape_html(normTail) + "</code></pre>\n";
        }
        if (in_tbl)
        {
            frameOut = frameOut + this._tbl_prefix + this._render_table_from_buffer();
        }

        # flush paragraph if open
        if (in_p)  { frameOut = frameOut + this._flush_paragraph(); in_p = false; }

        if (in_ul) { frameOut = frameOut + "</ul>\n"; }
        if (in_ol) { frameOut = frameOut + "</ol>\n"; }

        # close any remaining open blockquotes
        if (bq_level > 0)
        {
            var k = 0;
            while (k < bq_level) { frameOut = frameOut + "</blockquote>\n"; k = k + 1; }
        }

        return frameOut;
    }

    func _looks_like_ol_item(line)
    {
        var i = 0; var L = line.len(); var hasDigit = false;

        # führende Ziffern sammeln
        while (i < L && line.substr(i,1) >= "0" && line.substr(i,1) <= "9")
        {
            hasDigit = true;
            i = i + 1;
        }

        if (!hasDigit) { return false; }

        # genau ". " danach erforderlich (z.B. "1. ", "23. ")
        if (i + 1 < L && line.substr(i,2) == ". ") { return true; }

        return false;
    }


    # --- per-line renderer ---
    func _render_line(line, in_ul, in_ol, in_p, in_code, in_tbl, bq_level)
    {
        this._state = { "ul": in_ul, "ol": in_ol, "p": in_p, "code": in_code, "tbl": in_tbl, "bq": bq_level };

        line = this._rtrim(line);

        # fenced code ```
        if (this._starts_with(line, "```"))
        {
            if (!in_code)
            {
                # flush paragraph before entering code
                var pre = this._flush_paragraph_if(in_p);
                this._state["p"] = false;
                this._state["code"] = true;
                this._codebuf = "";
                return pre + "<pre><code>";
            }
            else
            {
                var norm = this._normalize_code_block(this._codebuf);
                this._state["code"] = false;
                return this._escape_html(norm) + "</code></pre>\n";
            }
        }

        # inside fenced code: buffer only
        if (in_code) { this._codebuf = this._codebuf + line + "\n"; return ""; }

        # -------------- TABLE HANDLING --------------
        var isRow = this._is_table_row(line);

        if (isRow)
        {
            if (!in_tbl)
            {
                # starting a new table: close paragraphs/lists first
                this._tbl_prefix = this._close_lists_paras(in_ul, in_ol, in_p);
                this._tbuf = "";
                in_ul = false; in_ol = false; in_p = false;
                this._state["ul"] = false; this._state["ol"] = false; this._state["p"] = false;
            }

            this._tbuf = this._tbuf + line + "\n";
            this._state["tbl"] = true;
            return "";
        }

        if (in_tbl && !isRow)
        {
            var htmlTable = this._tbl_prefix + this._render_table_from_buffer();
            this._state["tbl"] = false;

            # process current non-table line normally (recursive call)
            var rest = this._render_line(line, this._state["ul"], this._state["ol"], this._state["p"], this._state["code"], false, bq_level);
            return htmlTable + rest;
        }
        # ------------ END TABLE HANDLING ------------

        # horizontal rule
        if (this._is_hr(line)) { return this._close_lists_paras(in_ul, in_ol, in_p) + "<hr/>\n"; }

        # --- HTML block passthrough ---
        if (this._is_html_block(line))
        {
            return this._close_lists_paras(in_ul, in_ol, in_p) + line + "\n";
        }

        # --- nested blockquotes ---
        var lvl = this._bq_level(line);
        if (lvl > 0)
        {
            var inner = line.slice(lvl);
            inner = this._ltrim(inner);
            inner = this._render_inline(inner);

            var s_bq = "";
            # adjust to target level
            while (bq_level < lvl) { s_bq = s_bq + this._close_lists_paras(in_ul, in_ol, in_p) + "<blockquote>"; bq_level = bq_level + 1; in_ul=false; in_ol=false; in_p=false; }
            while (bq_level > lvl) { s_bq = s_bq + "</blockquote>\n"; bq_level = bq_level - 1; }

            this._state["bq"] = bq_level;
            return s_bq + inner + "\n";
        }

        # If previously inside blockquotes but current line isn't, close them all and re-process the line
        if (bq_level > 0)
        {
            var s_close = "";
            var k = 0;
            while (k < bq_level) { s_close = s_close + "</blockquote>\n"; k = k + 1; }
            bq_level = 0; this._state["bq"] = 0;

            return s_close + this._render_line(line, in_ul, in_ol, in_p, in_code, false, bq_level);
        }

        # headings (ATX) with id
        var h = this._heading_level(line);
        if (h > 0)
        {
            var raw = this._lstrip_hash_space(line, h);
            var id  = this._slugify(raw);
            var content = this._render_inline(raw);
            var tag = "h" + h;
            return this._close_lists_paras(in_ul, in_ol, in_p) + "<" + tag + " id=\"" + id + "\">" + content + "</" + tag + ">\n";
        }

        # Setext underline detection -> headings with id
        if (this._is_setext_h1(line) && in_p)
        {
            var rawtxt = this._get_pbuf_text();
            this._state["p"] = false;
            var id1 = this._slugify(rawtxt);
            return "<h1 id=\"" + id1 + "\">" + this._render_inline(rawtxt) + "</h1>\n";
        }
        if (this._is_setext_h2(line) && in_p)
        {
            var rawtxt2 = this._get_pbuf_text();
            this._state["p"] = false;
            var id2 = this._slugify(rawtxt2);
            return "<h2 id=\"" + id2 + "\">" + this._render_inline(rawtxt2) + "</h2>\n";
        }

        # unordered list
        if (this._starts_with(line, "- ") || this._starts_with(line, "* ") || this._starts_with(line, "+ "))
        {
            var body = line.slice(2);
            body = this._render_inline(body);

            var s = "";
            if (!in_ul) { s = this._flush_paragraph_if(in_p) + (in_ol ? "</ol>\n" : "") + "<ul>\n"; in_ul = true; in_ol = false; in_p = false; }
            s = s + "<li>" + body + "</li>\n";

            this._state["ul"] = in_ul; this._state["ol"] = in_ol; this._state["p"] = in_p;
            return s;
        }

        # ordered list
        if (this._looks_like_ol_item(line))
        {
            var dot = this._find(line, ". ");
            var body2 = line.slice(dot + 2);
            body2 = this._render_inline(body2);

            var s2 = "";
            if (!in_ol) { s2 = this._flush_paragraph_if(in_p) + (in_ul ? "</ul>\n" : "") + "<ol>\n"; in_ol = true; in_ul = false; in_p = false; }
            s2 = s2 + "<li>" + body2 + "</li>\n";

            this._state["ul"] = in_ul; this._state["ol"] = in_ol; this._state["p"] = in_p;
            return s2;
        }

        # blank line => close paragraph/lists
        if (this._is_blank(line))
        {
            var s3 = "";
            if (in_p)  { s3 = s3 + this._flush_paragraph();  in_p = false; }
            if (in_ul) { s3 = s3 + "</ul>\n"; in_ul = false; }
            if (in_ol) { s3 = s3 + "</ol>\n"; in_ol = false; }
            this._state["ul"] = in_ul; this._state["ol"] = in_ol; this._state["p"] = in_p;
            return s3;
        }

        # paragraph text (buffered)
        var text = this._render_inline(line);
        if (!in_p) { this._pbuf = ""; in_p = true; }
        this._pbuf = this._pbuf + text + "\n";
        this._state["ul"] = in_ul; this._state["ol"] = in_ol; this._state["p"] = in_p;
        return "";  # delay output until we know if it's Setext or a normal paragraph
    }

    # --- PARAGRAPH HELPERS (Setext) -----------------------------------

    func _get_pbuf_text()
    {
        var s = this._pbuf;
        if (s.len() > 0 && s.substr(s.len()-1,1) == "\n") { s = s.substr(0, s.len()-1); }
        return s;
    }

    func _flush_paragraph_if(in_p)
    {
        if (in_p) { return this._flush_paragraph(); }
        return "";
    }

    func _flush_paragraph()
    {
        var txt = this._get_pbuf_text();
        this._pbuf = "";
        return "<p>" + txt + "</p>\n";
    }

    func _is_setext_h1(s)
    {
        var x = this._ltrim(s);
        if (x.len() < 3) { return false; }
        var i = 0; var L = x.len();
        while (i < L) { if (x.substr(i,1) != "=") { return false; } i = i + 1; }
        return true;
    }

    func _is_setext_h2(s)
    {
        var x = this._ltrim(s);
        if (x.len() < 3) { return false; }
        var i = 0; var L = x.len();
        while (i < L) { if (x.substr(i,1) != "-") { return false; } i = i + 1; }
        return true;
    }

    # --- INLINE RENDERING ---------------------------------------------

    func _render_inline(t)
    {
        # reset buffers
        this._math = []; this._mathi = 0;
        this._spans = []; this._spani = 0;

        # 1) Code-Spans schützen (Backticks), damit $...$ darin NICHT als Mathe erkannt wird
        t = this._protect_spans(t, "`");

        # 2) Mathe schützen (erst $$...$$, dann $...$)
        t = this._protect_math(t, "$$");
        t = this._protect_math(t, "$");

        # 3) Auto-Links in <...> (http/https/mailto oder plain E-Mail)
        t = this._replace_autolinks(t);

        # 4) whitelist de-escape für HTML
        t = this._unescape_whitelisted_html_entities(t);

        # 5) Bilder/Links im Markdown-Stil
        t = this._replace_links_or_images(t, true);
        t = this._replace_links_or_images(t, false);

        # 6) Inline-Code/Bold/Italic (Code ist geschützt)
        #    Wichtig: Backticks selbst werden erst nach dem Restore konvertiert.
        t = this._replace_double_delim(t, "**", "<strong>", "</strong>");
        t = this._replace_delimited(t, "*",  "<em>", "</em>");

        # 7) HTML escapen (unter Erhalt unserer Tags)
        t = this._escape_html_preserving_tags(t);

        # 8) Mathe zurück (raw, mit $-Delimitern; KaTeX rendert später)
        t = this._restore_math(t);

        # 9) Code-Spans zurück und danach erst zu <code> machen
        t = this._restore_spans(t);
        t = this._replace_delimited(t, "`", "<code>", "</code>");

        # 10) Deep-Unescape für erlaubte HTML-Tags
        t = this._deep_unescape_whitelist(t);

        return t;
    }

    func _protect_math(s, delim)
    {
        var frameOut = "";
        var i = 0; var L = s.len();
        var dL = delim.len();
        var open = -1;

        while (i <= L - dL)
        {
            if (s.substr(i, dL) == delim)
            {
                if (open < 0) { open = i; i = i + dL; continue; }
                # close
                var seg = s.substr(open, (i + dL) - open);  # includes both delimiters
                var key = "§M" + this._mathi + "§";
                this._math.push(seg);
                this._mathi = this._mathi + 1;

                frameOut = frameOut + s.substr(0, open) + key;
                s = s.substr(i + dL, L - (i + dL));
                L = s.len(); i = 0; open = -1;
                continue;
            }
            i = i + 1;
        }
        frameOut = frameOut + s;  # tail
        return frameOut;
    }

    func _restore_math(s)
    {
        var i = 0;
        while (i < this._math.len())
        {
            var key = "§M" + i + "§";
            s = s.replace(key, this._math[i]);
            i = i + 1;
        }
        return s;
    }

    # --- Code-span masking (Backticks) --------------------------------

    func _protect_spans(s, delim)   # delim = "`"
    {
        var frameOut = "";
        var i = 0; var L = s.len();
        var dL = delim.len();
        var open = -1;

        while (i <= L - dL)
        {
            if (s.substr(i, dL) == delim)
            {
                if (open < 0) { open = i; i = i + dL; continue; }
                # schließen
                var seg = s.substr(open, (i + dL) - open);  # inkl. Backticks
                var key = "§C" + this._spani + "§";
                this._spans.push(seg);
                this._spani = this._spani + 1;

                frameOut = frameOut + s.substr(0, open) + key;
                s = s.substr(i + dL, L - (i + dL));
                L = s.len(); i = 0; open = -1;
                continue;
            }
            i = i + 1;
        }
        frameOut = frameOut + s;  # Rest
        return frameOut;
    }

    func _restore_spans(s)
    {
        var i = 0;
        while (i < this._spans.len())
        {
            var key = "§C" + i + "§";
            s = s.replace(key, this._spans[i]);
            i = i + 1;
        }
        return s;
    }

    # --- Auto-links in <...> ------------------------------------------

    func _looks_like_email(s)
    {
        if (this._find(s, " ") >= 0) { return false; }
        if (this._find(s, "<") >= 0) { return false; }
        if (this._find(s, ">") >= 0) { return false; }
        var at = this._find(s, "@");
        if (at < 1) { return false; }
        var dot = this._find_from(s, ".", at+1);
        return (dot > at+1);
    }

    func _is_autolink_target(s)
    {
        if (this._starts_with(s, "http://") || this._starts_with(s, "https://")) { return true; }
        if (this._starts_with(s, "mailto:")) { return true; }
        if (this._looks_like_email(s)) { return true; }
        return false;
    }

    func _replace_autolinks(s)
    {
        var frameOut = ""; var i = 0; var L = s.len();
        while (i < L)
        {
            var c = s.substr(i,1);
            if (c == "<")
            {
                var j = this._scan_to(s, i+1, ">");
                if (j > i+1)
                {
                    var inside = s.substr(i+1, j - (i+1));
                    if (this._is_autolink_target(inside))
                    {
                        var href = inside;
                        var label = inside;
                        if (!this._starts_with(inside, "http://") && !this._starts_with(inside, "https://"))
                        {
                            if (!this._starts_with(inside, "mailto:") && this._looks_like_email(inside))
                            {
                                href = "mailto:" + inside;
                            }
                        }
                        frameOut = frameOut + "<a href=\"" + this._escape_html(href) + "\">" + this._escape_html(label) + "</a>";
                        i = j + 1;
                        continue;
                    }
                }
            }
            frameOut = frameOut + c;
            i = i + 1;
        }
        return frameOut;
    }

    # --- HTML / IDs helpers -------------------------------------------

    func _is_html_block(line)
    {
        var x = this._ltrim(line);
        if (x.len() == 0) { return false; }
        if (x.substr(0,4) == "<!--") { return true; }
        var c = x.substr(0,1);
        if (c == "<")
        {
            if (x.len() >= 2)
            {
                var c2 = x.substr(1,1);
                if ((c2 >= "A" && c2 <= "Z") || (c2 >= "a" && c2 <= "z") || c2 == "/") { return true; }
            }
        }
        return false;
    }

    func _slugify(s)
    {
        # strip inline tags quickly
        s = s.replace("**", ""); s = s.replace("*", ""); s = s.replace("`", "");
        # German umlauts
        s = s.replace("ä","a"); s = s.replace("ö","o"); s = s.replace("ü","u"); s = s.replace("Ä","a"); s = s.replace("Ö","o"); s = s.replace("Ü","u");
        s = s.replace("ß","ss");
        # lower + keep letters/digits/space/hyphen
        var frameOut = ""; var i = 0; var L = s.len();
        while (i < L)
        {
            var ch = s.substr(i,1);
            ch = chr(ch);
            # to lower approx
            if (ch >= 'A' && ch <= 'Z') { var o = (ch & 0xFF) + 32; ch = chr(o); }
            if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch == ' ' || ch == '-')
            { frameOut = frameOut + ch; }
            else { frameOut = frameOut + " "; }
            i = i + 1;
        }
        # collapse spaces -> hyphens
        frameOut = frameOut.replace("  ", " "); frameOut = frameOut.replace("  ", " ");
        frameOut = frameOut.replace(" ", "-");
        while (true)
        {
            var prev = frameOut;
            frameOut = frameOut.replace("--", "-");
            if (frameOut == prev) { break; }
        }
        # trim leading/trailing hyphens
        while (frameOut.len() > 0 && frameOut.substr(0,1) == "-") { frameOut = frameOut.slice(1); }
        while (frameOut.len() > 0 && frameOut.substr(frameOut.len()-1,1) == "-") { frameOut = frameOut.substr(0, frameOut.len()-1); }
        return frameOut;
    }

    # --- Whitelist HTML entity (un)escape helpers ---------------------

    func _unescape_whitelisted_html_entities(s)
    {
        while (true)
        {
            var before = s;
            s = s.replace("&amp;amp;", "&amp;");
            s = s.replace("&amp;lt;",  "&lt;");
            s = s.replace("&amp;gt;",  "&gt;");
            s = s.replace("&amp;quot;","&quot;");
            if (s == before) { break; }
        }

        s = s.replace("&lt;code&gt;", "<code>");
        s = s.replace("&lt;/code&gt;", "</code>");
        s = s.replace("&lt;strong&gt;", "<strong>");
        s = s.replace("&lt;/strong&gt;", "</strong>");
        s = s.replace("&lt;em&gt;", "<em>");
        s = s.replace("&lt;/em&gt;", "</em>");
        s = s.replace("&lt;br/&gt;", "<br/>");

        s = s.replace("&lt;/a&gt;", "</a>");
        s = s.replace("&lt;a ", "<a ");
        s = this._fix_open_tag_gt(s, "<a ");

        # allow raw <img ...>
        s = s.replace("&lt;img ", "<img ");
        s = this._fix_open_tag_gt(s, "<img ");

        # allow some common inline HTML tags
        s = s.replace("&lt;span ", "<span ");
        s = this._fix_open_tag_gt(s, "<span ");
        s = s.replace("&lt;div ", "<div ");
        s = this._fix_open_tag_gt(s, "<div ");
        s = s.replace("&lt;/div&gt;", "</div>");
        s = s.replace("&lt;details&gt;", "<details>");
        s = s.replace("&lt;/details&gt;", "</details>");
        s = s.replace("&lt;summary&gt;", "<summary>");
        s = s.replace("&lt;/summary&gt;", "</summary>");
        s = s.replace("&lt;sup&gt;", "<sup>");
        s = s.replace("&lt;/sup&gt;", "</sup>");
        s = s.replace("&lt;sub&gt;", "<sub>");
        s = s.replace("&lt;/sub&gt;", "</sub>");

        return s;
    }

    func _deep_unescape_whitelist(s)
    {
        while (true)
        {
            var before = s;
            s = s.replace("&amp;amp;", "&amp;");
            s = s.replace("&amp;lt;",  "&lt;");
            s = s.replace("&amp;gt;",  "&gt;");
            s = s.replace("&amp;quot;","&quot;");
            if (s == before) { break; }
        }

        s = s.replace("&lt;code&gt;", "<code>");
        s = s.replace("&lt;/code&gt;", "</code>");
        s = s.replace("&lt;strong&gt;", "<strong>");
        s = s.replace("&lt;/strong&gt;", "</strong>");
        s = s.replace("&lt;em&gt;", "<em>");
        s = s.replace("&lt;/em&gt;", "</em>");
        s = s.replace("&lt;br/&gt;", "<br/>");

        s = s.replace("&lt;/a&gt;", "</a>");
        s = s.replace("&lt;a ", "<a ");
        s = this._fix_open_tag_gt(s, "<a ");

        s = s.replace("&lt;img ", "<img ");
        s = this._fix_open_tag_gt(s, "<img ");

        s = s.replace("&lt;span ", "<span ");
        s = this._fix_open_tag_gt(s, "<span ");
        s = s.replace("&lt;div ", "<div ");
        s = this._fix_open_tag_gt(s, "<div ");
        s = s.replace("&lt;/div&gt;", "</div>");
        s = s.replace("&lt;details&gt;", "<details>");
        s = s.replace("&lt;/details&gt;", "</details>");
        s = s.replace("&lt;summary&gt;", "<summary>");
        s = s.replace("&lt;/summary&gt;", "</summary>");
        s = s.replace("&lt;sup&gt;", "<sup>");
        s = s.replace("&lt;/sup&gt;", "</sup>");
        s = s.replace("&lt;sub&gt;", "<sub>");
        s = s.replace("&lt;/sub&gt;", "</sub>");
        return s;
    }

    # --- TABLE HELPERS -------------------------------------------------

    func _is_table_row(line)
    {
        var x = this._ltrim(line);
        if (x.len() < 2) { return false; }
        if (x.substr(0,1) != "|") { return false; }
        var i = 1; var L = x.len();
        while (i < L) { if (x.substr(i,1) == "|") { return true; } i = i + 1; }
        return false;
    }

    func _split_pipe(line)
    {
        line = this._ltrim(this._rtrim(line));
        if (line.substr(0,1) == "|") { line = line.slice(1); }
        if (line.len() > 0 && line.substr(line.len()-1,1) == "|")
        {
            line = line.substr(0, line.len()-1);
        }

        var cells = [];
        var cur = "";
        var i = 0; var L = line.len();
        while (i < L)
        {
            var ch = line.substr(i,1);
            if (ch == "|") { cells.push(this._ltrim(this._rtrim(cur))); cur = ""; }
            else { cur = cur + ch; }
            i = i + 1;
        }
        cells.push(this._ltrim(this._rtrim(cur)));
        return cells;
    }

    func _parse_aligns(line)
    {
        var segs = this._split_pipe(line);
        var frameOut = [];
        var i = 0;
        while (i < segs.len())
        {
            var s = this._ltrim(this._rtrim(segs[i]));
            var left  = (s.len() > 0 && s.substr(0,1) == ":");
            var right = (s.len() > 0 && s.substr(s.len()-1,1) == ":");
            var align = "left";
            if (left && right) { align = "center"; }
            else if (right)    { align = "right"; }
            else               { align = "left"; }
            frameOut.push(align);
            i = i + 1;
        }
        return frameOut;
    }

    func _render_table_from_buffer()
    {
        var rows = [];
        var buf = this._tbuf; var i = 0; var L = buf.len(); var acc = "";
        while (i < L)
        {
            var ch = buf.substr(i,1);
            if (ch != "\n") { acc = acc + ch; }
            else { rows.push(acc); acc = ""; }
            i = i + 1;
        }
        if (acc.len() > 0) { rows.push(acc); }

        if (rows.len() < 2) { return ""; }

        var headerCells = this._split_pipe(rows[0]);
        var aligns      = this._parse_aligns(rows[1]);

        var k = aligns.len();
        while (k < headerCells.len()) { aligns.push("left"); k = k + 1; }

        var html = "<table>\n<thead><tr>";
        var j = 0;
        while (j < headerCells.len())
        {
            var a = aligns[j];
            var cell = this._render_inline(headerCells[j]);
            html = html + "<th align=\"" + a + "\">" + cell + "</th>";
            j = j + 1;
        }
        html = html + "</tr></thead>\n<tbody>\n";

        var r = 2;
        while (r < rows.len())
        {
            var data = this._split_pipe(rows[r]);
            html = html + "<tr>";
            j = 0;
            while (j < headerCells.len())
            {
                var txt = (j < data.len()) ? data[j] : "";
                var a2 = aligns[j];
                html = html + "<td align=\"" + a2 + "\">" + this._render_inline(txt) + "</td>";
                j = j + 1;
            }
            html = html + "</tr>\n";
            r = r + 1;
        }

        html = html + "</tbody>\n</table>\n";
        return html;
    }

    # --- link/image parsing (raw passthrough for non-matches) ---------

    func _replace_links_or_images(s, isImg)
    {
        var frameOut = "";
        var i = 0; var L = s.len();
        while (i < L)
        {
            var bang = (isImg && s.substr(i,1) == "!");
            var openSqIdx = i + (bang ? 1 : 0);
            if ((bang || !isImg) && openSqIdx < L && s.substr(openSqIdx,1) == "[")
            {
                var endSq = this._scan_to(s, openSqIdx + 1, "]");
                if (endSq >= 0 && endSq + 1 < L && s.substr(endSq + 1,1) == "(")
                {
                    var endPar = this._scan_to(s, endSq + 2, ")");
                    if (endPar >= 0)
                    {
                        frameOut = frameOut + s.substr(0, i);  # prefix raw

                        var txt = s.substr(openSqIdx + 1, endSq - (openSqIdx + 1));
                        var url = s.substr(endSq + 2, endPar - (endSq + 2));
                        txt = this._escape_html(txt);
                        url = this._escape_html(url);

                        if (isImg) frameOut = frameOut + "<img src=\"" + url + "\" alt=\"" + txt + "\"/>";
                        else       frameOut = frameOut + "<a href=\"" + url + "\">" + txt + "</a>";

                        s = s.substr(endPar + 1, L - (endPar + 1));
                        L = s.len();
                        i = 0;
                        continue;
                    }
                }
            }
            i = i + 1;
        }
        frameOut = frameOut + s;  # tail raw
        return frameOut;
    }

    # --- misc helpers --------------------------------------------------

    func _bq_level(s)
    {
        var i = 0; var L = s.len(); var c = 0;
        while (i < L && s.substr(i,1) == ">") { c = c + 1; i = i + 1; }
        return c;
    }

    func _scan_to(s, start, needle)
    {
        var i = start; var L = s.len();
        while (i < L) { if (s.substr(i,1) == needle) { return i; } i = i + 1; }
        return -1;
    }

    func _find(s, pat)
    {
        var n = s.len(); var m = pat.len();
        if (m == 0) { return 0; }
        var i = 0; while (i <= n - m) { if (s.substr(i, m) == pat) { return i; } i = i + 1; }
        return -1;
    }

    func _find_from(s, pat, start)
    {
        var n = s.len(); var m = pat.len();
        if (m == 0) { return start; }
        var i = start; while (i <= n - m) { if (s.substr(i, m) == pat) { return i; } i = i + 1; }
        return -1;
    }

    func _fix_open_tag_gt(s, tagPrefix)
    {
        var frameOut = ""; var pos = 0;
        while (true)
        {
            var i = this._find_from(s, tagPrefix, pos);
            if (i < 0) { frameOut = frameOut + s.substr(pos, s.len() - pos); break; }
            frameOut = frameOut + s.substr(pos, i - pos);
            frameOut = frameOut + tagPrefix;

            var j = this._find_from(s, "&gt;", i + tagPrefix.len());
            if (j < 0)
            {
                frameOut = frameOut + s.substr(i + tagPrefix.len(), s.len() - (i + tagPrefix.len()));
                break;
            }

            var attrs = s.substr(i + tagPrefix.len(), j - (i + tagPrefix.len()));
            frameOut = frameOut + attrs + ">";
            pos = j + 4;
        }
        return frameOut;
    }

    func _collapse_amp(s)
    {
        while (true)
        {
            var nxt = s.replace("&amp;amp;", "&amp;");
            if (nxt == s) { break; }
            s = nxt;
        }
        return s;
    }

    func _stitch_split_entities(s)
    {
        while (true)
        {
            var prev = s;
            s = s.replace("&amp;\nlt;",   "&amp;lt;");
            s = s.replace("&amp;\ngt;",   "&amp;gt;");
            s = s.replace("&amp;\namp;",  "&amp;amp;");
            s = s.replace("&amp;\nquot;", "&amp;quot;");
            if (s == prev) { break; }
        }
        return s;
    }

    func _normalize_code_block(buf)
    {
        var s = buf;
        s = this._collapse_amp(s);
        s = this._stitch_split_entities(s);
        return s; # escape on write
    }

    func _is_blank(s)
    {
        var i = 0; var L = s.len();
        while (i < L) { var c = s.substr(i,1); if (c != " " && c != "\t") { return false; } i = i + 1; }
        return true;
    }

    func _ltrim(s)
    {
        var i = 0; var L = s.len();
        while (i < L && (s.substr(i,1) == " " || s.substr(i,1) == "\t")) { i = i + 1; }
        if (i <= 0) { return s; } return s.slice(i);
    }

    func _rtrim(s)
    {
        var L = s.len(); var i = L - 1;
        while (i >= 0 && (s.substr(i,1) == " " || s.substr(i,1) == "\t")) { i = i - 1; }
        return s.substr(0, i + 1);
    }

    func _starts_with(s, p) { return s.len() >= p.len() && s.substr(0, p.len()) == p; }

    func _heading_level(s)
    {
        var cnt = 0; var i = 0; var L = s.len();
        while (i < L && s.substr(i,1) == "#") { cnt = cnt + 1; i = i + 1; if (cnt == 6) { break; } }
        if (cnt == 0) { return 0; }
        if (i < L && s.substr(i,1) == " ") { return cnt; }
        return 0;
    }

    func _lstrip_hash_space(s, n)
    {
        var i = 0; var L = s.len(); var c = 0;
        while (i < L && c < n && s.substr(i,1) == "#") { i = i + 1; c = c + 1; }
        if (i < L && s.substr(i,1) == " ") { i = i + 1; }
        return s.slice(i);
    }

    func _lstrip_one(s, pref)
    {
        if (this._starts_with(s, pref)) { return s.slice(pref.len()); }
        return s;
    }

    func _is_hr(s)
    {
        var x = this._ltrim(s);
        return (x == "---" || x == "***");
    }

    func _close_paragraph(in_p) { if (in_p) { return this._flush_paragraph(); } return ""; }

    func _close_lists(in_ul, in_ol)
    {
        var s = "";
        if (in_ul) { s = s + "</ul>\n"; }
        if (in_ol) { s = s + "</ol>\n"; }
        return s;
    }

    func _close_lists_paras(in_ul, in_ol, in_p)
    {
        var s = "";
        if (in_p)  { s = s + this._flush_paragraph(); }
        if (in_ul) { s = s + "</ul>\n"; }
        if (in_ol) { s = s + "</ol>\n"; }
        return s;
    }

    func _escape_html(s)
    {
        s = s.replace("&", "&amp;");
        s = s.replace("<", "&lt;");
        s = s.replace(">", "&gt;");
        return s;
    }

    func _escape_html_preserving_tags(s)
    {
        var masks = [
            "<strong>", "</strong>", "<em>", "</em>", "<code>", "</code>",
            "<a href=\"", "\">", "</a>", "<img src=\"", "\" alt=\"", "\"/>",
            "<p>", "</p>", "<ul>", "</ul>", "<ol>", "</ol>", "<li>", "</li>",
            "<h1>", "</h1>", "<h2>", "</h2>", "<h3>", "</h3>", "<h4>", "</h4>", "<h5>", "</h5>", "<h6>", "</h6>",
            "<pre>", "</pre>", "<blockquote>", "</blockquote>", "<hr/>", "<br/>",
            "<table>", "</table>", "<thead>", "</thead>", "<tbody>", "</tbody>", "<tr>", "</tr>", "<th", "</th>", "<td", "</td>",
            "<span ", "</span>", "<div ", "</div>", "<details>", "</details>", "<summary>", "</summary>", "<sup>", "</sup>", "<sub>", "</sub>"
        ];

        var repl = [];
        var k = 0;
        while (k < masks.len())
        {
            var token = masks[k];
            var key = "§" + k + "§";
            s = s.replace(token, key);
            repl.push(token);
            k = k + 1;
        }

        s = this._escape_html(s);

        k = 0;
        while (k < masks.len())
        {
            var key2 = "§" + k + "§";
            s = s.replace(key2, repl[k]);
            k = k + 1;
        }
        return s;
    }

    func _replace_delimited(s, mark, openTag, closeTag)
    {
        var frameOut = "";
        var i = 0; var L = s.len();
        var open = false; var last = 0;

        while (i < L)
        {
            if (s.substr(i, mark.len()) == mark)
            {
                var chunk = s.substr(last, i - last);
                if (!open) { frameOut = frameOut + this._escape_html(chunk) + openTag; }
                else       { frameOut = frameOut + this._escape_html(chunk) + closeTag; }
                open = !open;
                i = i + mark.len();
                last = i;
            }
            else { i = i + 1; }
        }
        frameOut = frameOut + this._escape_html(s.substr(last, L - last));
        return frameOut;
    }

    func _replace_double_delim(s, mark2, openTag, closeTag)
    {
        var frameOut = "";
        var i = 0; var L = s.len();
        var open = false; var last = 0; var mL = mark2.len();

        while (i <= L - mL)
        {
            if (s.substr(i, mL) == mark2)
            {
                var chunk = s.substr(last, i - last);
                if (!open) { frameOut = frameOut + this._escape_html(chunk) + openTag; }
                else       { frameOut = frameOut + this._escape_html(chunk) + closeTag; }
                open = !open;
                i = i + mL;
                last = i;
            }
            else { i = i + 1; }
        }
        frameOut = frameOut + this._escape_html(s.substr(last, L - last));
        return frameOut;
    }
}

# ==========================================
# Simple HTTP server that serves a MD file (includes KaTeX CDN)
# ==========================================

class MdServer
{
    var port;
    var path;
    var srv;
    var renderer;

    func init(port, path)
    {
        this.port = port;
        this.path = path;
        this.renderer = new MdRenderer();
    }

    func run()
    {
        this.srv = http_server(this.port);
        this.srv.start();

        print("Serving " + this.path + " at http://localhost:" + this.port);

        var running = true;
        while (running)
        {
            var req = this.srv.poll(200);
            if (req == null) { continue; }

            if (req["path"] == "/stop")
            {
                this.srv.respond(req["id"], 200, "Bye!", { "Content-Type": "text/plain" });
                this.srv.stop(); this.srv.close();
                running = false;
                continue;
            }

            var md = this._read_all(this.path);
            var html = this._wrap_html(this.renderer.render(md));
            this.srv.respond(req["id"], 200, html, { "Content-Type": "text/html; charset=utf-8" });
        }
    }

    func _read_all(p)
    {
        var fh = fopen(p, 0);  # read
        var s = "";
        while (!fh.eof())
        {
            var line = fh.readline();
            s = s + line + "\n";
        }
        fh.close();
        return s;
    }

    func _wrap_html(body)
    {
        var head = ""
        + "<!doctype html><html><head><meta charset=\"utf-8\"/>"
        + "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/>"
        + "<title>Configuration Language</title>"
        + "<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css\">"
        + "<script defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js\"></script>"
        + "<script defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js\" onload=\"renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});\"></script>"
        + "<style>"
        + "body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;"
        + "margin:0;padding:40px;line-height:1.6;background:radial-gradient(1000px 600px at 20% -10%,#1f2a3b 0,#0b0f16 60%);color:#e8eef8;}"
        + "a{color:#88c0ff;text-decoration:none}a:hover{text-decoration:underline}"
        + "pre{background:#0f1621;border:1px solid #1e293b;padding:16px;border-radius:12px;overflow:auto}"
        + "code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}"
        + "blockquote{border-left:4px solid #3b82f6;padding:8px 16px;margin:12px 0;background:rgba(59,130,246,.08);border-radius:6px}"
        + "ul,ol{padding-left:28px}"
        + "h1,h2,h3,h4,h5,h6{line-height:1.25;margin:24px 0 12px}"
        + "h1{font-size:2rem}h2{font-size:1.6rem}h3{font-size:1.3rem}"
        + "p{margin:12px 0}"
        + "hr{border:0;border-top:1px solid #334155;margin:24px 0}"
        + "table{border-collapse:collapse;width:100%;margin:16px 0;border:1px solid #334155;border-radius:12px;overflow:hidden}"
        + "thead th{background:#0f1621;border-bottom:1px solid #1e293b;padding:10px 12px;text-align:left}"
        + "tbody td{border-top:1px solid #1e293b;padding:10px 12px;vertical-align:top}"
        + "tbody tr:nth-child(odd){background:rgba(148,163,184,.04)}"
        + "img{max-width:100%;height:auto;border-radius:8px}"
        + "</style></head><body>";
        var foot = "</body></html>";
        return head + body + foot;
    }
}
